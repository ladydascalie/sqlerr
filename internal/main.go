// Most of the logic in this file is based off the original comp_err.c
// used by mysql itself to parse the error message file and
// generate the mysqld_error.h header file.
package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"strings"
	"text/template"
	"time"
)

const rawFile = "https://raw.githubusercontent.com/mysql/mysql-server/5.7/sql/share/errmsg-utf8.txt"
const textFile = "errmsg-utf8.txt"
const errPrefix = "ER_"
const warnPrefix = "WARN_"

var errorOffset = 1000         // default value
var currentError = errorOffset // default value
var client = &http.Client{
	Timeout: 5 * time.Second,
}
var tpl = `
// Code generated by "make build"; DO NOT EDIT.

package sqlerr

const (
	{{range $k, $v := .}}
		{{ $v -}}
	{{end}}
)

//go:generate stringer -type=MySQLError
type MySQLError int`

func main() {
	// request the raw file
	resp, err := client.Get(rawFile)
	if err != nil {
		log.Printf("error connecting to github: %v", err)
	}
	// read it
	b, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Printf("error reading response body: %v", err)
	}
	defer resp.Body.Close()

	// save it
	infile, err := os.Create(textFile)
	if err != nil {
		log.Printf("error creating text file: %v", err)
	}
	defer infile.Close()
	if _, err := infile.Write(b); err != nil {
		log.Printf("error writing response to disk: %v", err)
	}
	infile, err = os.Open(textFile)
	if err != nil {
		log.Printf("error opening the infile: %v", err)
	}

	var declarations []string

	// scan the file
	scanner := bufio.NewScanner(infile)
	for scanner.Scan() {
		txt := scanner.Text()

		// check the given start error number
		if strings.HasPrefix(txt, "start-error-number") {
			// this is needed as there is a jump from error 1885 to 3000
			fmt.Sscanf(txt, "start-error-number %d", &errorOffset)
			currentError = errorOffset
		}
		// only lines that begin at column 0 are useful for us
		// therefore we are free to ignore those lines
		if strings.HasPrefix(txt, "\t") {
			continue
		}
		// lines must begin with the error or warning prefix
		if strings.HasPrefix(txt, errPrefix) || strings.HasPrefix(txt, warnPrefix) {
			// in some cases ANSI codes may be appended to the definition.
			// we do not need those, as only the generated codes will be returned by mysql.
			parts := strings.Split(txt, " ")
			parts[0] = strings.Trim(parts[0], ",")
			txt = parts[0]

			// this prepares a Go constant definition.
			// to be inserted into a multi-line const ( ... ) statement.
			decl := fmt.Sprintf("%s MySQLError = %d", txt, currentError)

			// append and increment the error.
			declarations = append(declarations, decl)
			currentError++
		}
	}

	// check for scan errors
	if err := scanner.Err(); err != nil {
		log.Fatal(err)
	}

	// execute the template into a buffer
	var buf bytes.Buffer
	t := template.Must(template.New("sqlerr").Parse(tpl))
	if err := t.Execute(&buf, declarations); err != nil {
		log.Fatal(err)
	}

	// format the new source code
	byt, err := format.Source(buf.Bytes())
	if err != nil {
		log.Printf("error formatting source: %v", err)
	}

	// create the outfile
	outfile, err := os.Create("../sqlerr.go")
	if err != nil {
		log.Printf("error opening outfile: %v", err)
	}

	// write it to disk
	if _, err := outfile.Write(byt); err != nil {
		log.Printf("error writing to disk: %v", err)
	}
}
